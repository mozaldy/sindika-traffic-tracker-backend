import sqlite3
import os
import cv2
import time
import logging
import numpy as np
from datetime import datetime

logger = logging.getLogger("db_manager")

class DatabaseManager:
    def __init__(self, db_path="traffic_data.db", captures_dir="captures"):
        self.db_path = db_path
        self.captures_dir = captures_dir
        
        if not os.path.exists(self.captures_dir):
            os.makedirs(self.captures_dir)
            
        self._init_db()

    def _init_db(self):
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS traffic_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp REAL,
                class_name TEXT,
                speed_kmh REAL,
                direction_deg REAL,
                direction_symbol TEXT,
                image_path TEXT,
                video_source TEXT,
                crossing_start REAL,
                crossing_end REAL,
                license_plate TEXT,
                plate_image_path TEXT
            )
        ''')
        
        # Migration 1: Direction Symbol
        c.execute("PRAGMA table_info(traffic_events)")
        existing_columns = [info[1] for info in c.fetchall()]
        
        if 'direction_symbol' not in existing_columns:
            print("Migrating DB: Adding direction_symbol column...")
            try:
                c.execute("ALTER TABLE traffic_events ADD COLUMN direction_symbol TEXT")
            except sqlite3.OperationalError:
                pass

        # Migration 2: Crossing Timestamps
        if 'crossing_start' not in existing_columns:
            try:
                c.execute('ALTER TABLE traffic_events ADD COLUMN crossing_start REAL')
            except sqlite3.OperationalError:
                pass
        
        if 'crossing_end' not in existing_columns:
            try:
                c.execute('ALTER TABLE traffic_events ADD COLUMN crossing_end REAL')
            except sqlite3.OperationalError:
                pass

        # Migration 3: License Plate
        if 'license_plate' not in existing_columns:
            try:
                c.execute('ALTER TABLE traffic_events ADD COLUMN license_plate TEXT')
            except sqlite3.OperationalError:
                pass
        
        if 'plate_image_path' not in existing_columns:
            try:
                c.execute('ALTER TABLE traffic_events ADD COLUMN plate_image_path TEXT')
            except sqlite3.OperationalError:
                pass
            
        conn.commit()
        conn.close()

    def log_event(self, frame: np.ndarray, bbox: list, class_name: str, speed: float, direction: float, direction_symbol: str = None, video_source="unknown", crossing_start=0.0, crossing_end=0.0, license_plate: str = None, plate_crop: np.ndarray = None):
        """
        Logs an event: Crops image, saves to disk, inserts into DB.
        bbox: [x1, y1, x2, y2]
        license_plate: OCR text from license plate (if detected)
        plate_crop: Cropped license plate image (if detected)
        """
        try:
            timestamp = time.time()
            dt_str = datetime.fromtimestamp(timestamp).strftime("%Y%m%d_%H%M%S_%f")
            
            # Crop Vehicle Image
            h, w = frame.shape[:2]
            x1, y1, x2, y2 = map(int, bbox)
            # Clamp coordinates
            x1, y1 = max(0, x1), max(0, y1)
            x2, y2 = min(w, x2), min(h, y2)
            
            if x2 > x1 and y2 > y1:
                crop = frame[y1:y2, x1:x2]
                filename = f"{dt_str}_{class_name}_{speed:.0f}kmh.jpg"
                file_path = os.path.join(self.captures_dir, filename)
                cv2.imwrite(file_path, crop)
            else:
                file_path = "" # Invalid crop

            # Save Plate Crop Image (if available)
            plate_image_path = ""
            if plate_crop is not None and plate_crop.size > 0:
                plate_filename = f"{dt_str}_plate.jpg"
                plate_image_path = os.path.join(self.captures_dir, plate_filename)
                cv2.imwrite(plate_image_path, plate_crop)

            # Insert into DB
            conn = sqlite3.connect(self.db_path)
            c = conn.cursor()
            c.execute('''
                INSERT INTO traffic_events (timestamp, class_name, speed_kmh, direction_deg, direction_symbol, image_path, video_source, crossing_start, crossing_end, license_plate, plate_image_path)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (timestamp, class_name, float(speed), float(direction), direction_symbol, file_path, video_source, crossing_start, crossing_end, license_plate, plate_image_path))
            conn.commit()
            conn.close()
            
            logger.info(f"Logged event: {class_name} @ {speed:.1f} km/h")
            
        except Exception as e:
            logger.error(f"Failed to log event: {e}")

    def get_events(self, limit=100, offset=0):
        """
        Retrieve events from DB.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            c = conn.cursor()
            c.execute('''
                SELECT * FROM traffic_events 
                ORDER BY timestamp DESC 
                LIMIT ? OFFSET ?
            ''', (limit, offset))
            rows = c.fetchall()
            conn.close()
            
            # Safe conversion to handle potential bytes/encoding issues
            results = []
            for row in rows:
                row_dict = dict(row)
                safe_dict = {}
                for k, v in row_dict.items():
                    if isinstance(v, bytes):
                        try:
                            safe_dict[k] = v.decode('utf-8')
                        except UnicodeDecodeError:
                            safe_dict[k] = v.decode('utf-8', errors='replace')
                            logger.warning(f"Field {k} contained bytes that failed to decode utf-8. Replaced.")
                    else:
                        safe_dict[k] = v
                results.append(safe_dict)
                
            return results
        except Exception as e:
            logger.error(f"Failed to get events: {e}")
            return []

    def delete_event(self, event_id):
        """
        Delete a specific event and its image.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            c = conn.cursor()
            
            # Get image path first
            c.execute('SELECT image_path FROM traffic_events WHERE id = ?', (event_id,))
            row = c.fetchone()
            
            if row:
                image_path = row['image_path']
                if image_path and os.path.exists(image_path):
                    try:
                        os.remove(image_path)
                    except OSError as err:
                        logger.warning(f"Failed to remove file {image_path}: {err}")

                c.execute('DELETE FROM traffic_events WHERE id = ?', (event_id,))
                conn.commit()
                return True
            
            conn.close()
            return False
        except Exception as e:
            logger.error(f"Failed to delete event {event_id}: {e}")
            return False

    def delete_all_events(self):
        """
        Clear all events and delete all capture files.
        """
        try:
            conn = sqlite3.connect(self.db_path)
            c = conn.cursor()
            c.execute('DELETE FROM traffic_events')
            conn.commit()
            conn.close()
            
            # Delete all files in captures directory
            if os.path.exists(self.captures_dir):
                for filename in os.listdir(self.captures_dir):
                    file_path = os.path.join(self.captures_dir, filename)
                    try:
                        if os.path.isfile(file_path):
                            os.unlink(file_path)
                    except Exception as e:
                        logger.warning(f"Failed to delete {file_path}: {e}")
            
            return True
        except Exception as e:
            logger.error(f"Failed to delete all events: {e}")
            return False
